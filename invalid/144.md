Tiny Viridian Beaver

medium

# Lack of timelock on the withdraw function of SdtBlackHole, enables to steal yield from other users

## Summary
The SdtStakingPositionService uses a time-based softlock to prevent users from withdrawing assets immediately after depositing them. However, this softlock does not apply to the SdtBlackHole, which allows users to withdraw most of their assets at any time. This creates an opportunity for malicious users to exploit the system.

## Vulnerability Detail
The withdraw function of the SdtStakingPositionService, uses a time-based softlock by the checkCompliance modifier to prevent users from exploiting the protocol for short-term gains. This mechanism charges a small percentage on withdrawals, preventing users from simply depositing their assets, accruing yield from other users, and withdrawing immediately.

However, this softlock does not apply to the withdraw function of the SdtBlackHole, which allow msg.sender to withdraw most of their underlying assets at any time after deposit. This creates an opportunity for malicious attacker to exploit the system by depositing their assets just before a gauge, gaining access to yield generated by other users, and then withdrawing the majority of their assets through the withdraw function. 

The small percentage charged on the remaining assets may not be enough to offset the yield gained, effectively allowing the malicious user to steal yield from other users. The amount of yield gained varies depending on the deposited amounts.

This issue involves 3 functions:

[SdtStakingPositionService.sol#L312C2-L331C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol#L312C2-L331C6)
[SdtStakingPositionManager.sol#L69C1-L83C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionManager.sol#L69C1-L83C6)

The withdraw(uint256 tokenId, uint256 amount) function in the SdtStakingPositionService contract calls the checkTokenFullCompliance(uint256 tokenId, address receiver) function in the sdtStakingPositionManager contract to ensure that the unlockingTimestampPerToken for the specified tokenId is less than the current block.timestamp. If this condition is not met, a error is reverted to the user.
```solidity
function checkTokenFullCompliance(uint256 tokenId, address receiver) external view {
        /// @dev Verify that receiver is always the NFT owner
        require(receiver == ownerOf(tokenId), "TOKEN_NOT_OWNED");
        /// @dev As the StakingPositionManager is the NFT contract, we verify that this ID has been created from this StakingPositionService
        require(msg.sender == stakingPerTokenId[tokenId], "WRONG_STAKING");
        /// @dev We verify that the tokenId is not timelocked
        require(unlockingTimestampPerToken[tokenId] < block.timestamp, "TOKEN_TIMELOCKED");
}
```

[SdtBlackHole.sol#L79C1-L87C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/StakeDAO/SdtBlackHole.sol#L79C1-L87C6)

The withdraw(address receiver, uint256 amount) function from the SdtBlackHole contract, which enables msg.sender to withdraw gauge token from this contract to return it to the user.

```solidity
function withdraw(address receiver, uint256 amount) external {
        require(cvgControlTower.isSdtStaking(msg.sender), "ONLY_SD_ASSET_STAKING");
        /// @dev Fetch the gaugeAsset on the associated Staking contract +  Tranfer the ERC20 token to the receiver
        ISdtStakingPositionService(msg.sender).stakingAsset().transfer(receiver, amount);
}
```

## Impact
This creates an opportunity for malicious users to exploit the system by depositing their assets just before a gauge, gaining access to yield generated by other users, and then withdrawing the majority of their assets. The small percentage charged on the remaining assets may not be enough to offset the yield gained, effectively allowing the malicious user to steal yield from other users.

## Code Snippet 
[SdtStakingPositionService.sol#L312C2-L331C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol#L312C2-L331C6)
[SdtStakingPositionManager.sol#L69C1-L83C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionManager.sol#L69C1-L83C6)
[SdtBlackHole.sol#L79C1-L87C6](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/StakeDAO/SdtBlackHole.sol#L79C1-L87C6)

## Tool used

Manual Review

## Recommendation
The same timelock logic that is applied to the withdraw function in SdtStakingPositionService contract could be applied to the withdraw function in the sdtStakingPositionManager contract, making this type of interaction unprofitable. 
