Precise Plum Shark

high

# Weak PRNG can compromise the security and randomness of `SdtStakingLogo` contract

## Summary
The function uses a modulo operation on the value to generate a random byte. This can compromise the security and randomness of the contract, as the modulo operation can be influenced by miners or other factors.

## Vulnerability Detail
The function `_toString()` uses a modulo operation on the value to generate a random byte at line 242. The function takes a uint256 value and converts it to a string by appending the digits to a buffer. The function uses the expression `value % 10` to get the last digit of the value and adds 48 to it to get the ASCII code of the digit. The function then casts the result to a bytes1 type and assigns it to the buffer. However, this modulo operation can be influenced by miners or other factors, such as the block timestamp, the block hash, or the value itself. This can compromise the security and randomness of the contract, as the modulo operation can produce predictable or biased results.

## Impact
Weak PRNG can have serious consequences for the security and randomness of the contract. For example, if the modulo operation produces predictable or biased results, then the function can generate strings that are not random or unique. This can affect the functionality and the aesthetics of the contract, as the function is used to generate the token URI for each token ID. Moreover, the weak PRNG can also make the contract vulnerable to attacks, such as brute force or replay attacks, where an attacker can guess or manipulate the strings generated by the function.

## Code Snippet
Source Link:- https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingLogo.sol#L229-L246

## Tool used
- Manual Review

## Recommendation
To improve the security and randomness of the contract, use a stronger PRNG that is not influenced by miners or other factors. Use a cryptographic hash function, such as keccak256, to generate a random byte from the value.
```diff
function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            // Vulnerable line: using modulo operation to generate a random byte
-            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
           // Fixed line: using keccak256 hash function to generate a random byte
+            buffer[digits] = bytes1(uint8(48 + uint256(keccak256(abi.encodePacked(value))) % 10));
            value /= 10;
        }
        return string(buffer);
    }

```